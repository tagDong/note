以前写程序时，很少关注单元测试。 即便写，也是草草了事。没有很认真的写过，更别谈统计代码覆盖率了。出现这种情况固然是不对的， 但也跟市面上缺乏准确有效的代码覆盖率统计工具有一丝关系吧。

golang的出现对这种局面有了一些改变。 golang定位于工程化语言，所以其也自带了一部分有用的辅助工具。而cover tool就是其中一个很有用的代码覆盖率统计工具。

golang的cover工具基本原理和其它工具类似，都是在原始代码中寻找分支，然后在每个分支"种下"锚点。 等所有的case都跑完后，通过统计执行锚点的数量来计算覆盖率。


golang使用-covermode来接受用户的统计指令:

set: 统计每个函数是否都执行了
count：统计每个函数执行了多少次
atomic：和count作用类似，但是用在并发场景中统计执行次数。
默认情况下，我们使用的都是set。 

go tool cover -html=coverage.out 
如此一来，我们就知道了。 只有getDPI函数覆盖了80%,其它两个函数丁点没有覆盖，因此加权之后就是17.4%了。

go tool cover -html=coverage.out  
log.Println(err.Error())被标红处理了，也就是说这行没有被覆盖到。 同理上面所有标红的代码都没有被覆盖到。
越绿的代码就表示调用次数越高，把鼠标移到上面就可以看到每行代码的调用次数。